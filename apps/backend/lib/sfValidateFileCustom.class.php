<?php
/**
 * sfValidatedFileCustom represents a resized uploaded file.
 *
 * @package    symfony
 * @subpackage validator
 * @author     fsommavilla
 * @version    0.1
 */
class sfValidatedFileCustom extends sfValidatedFile
{

   /**
    * Saves the uploaded file.
    *
    * This method can throw exceptions if there is a problem when saving the file.
    *
    * If you don't pass a file name, it will be generated by the generateFilename method.
    * This will only work if you have passed a path when initializing this instance.
    *
    * @param  string $file      The file path to save the file
    * @param  int    $fileMode  The octal mode to use for the new file
    * @param  bool   $create    Indicates that we should make the directory before moving the file
    * @param  int    $dirMode   The octal mode to use when creating the directory
    *
    * @return string The filename without the $this->path prefix
    *
    * @throws Exception
    */
   public function save($file = null, $fileMode = 0666, $create = true, $dirMode = 0777)
   {
      if (is_null($file))
      {
         $file = $this->generateFilename();
      }

      if ($file[0] != '/' && $file[0] != '\\' && !(strlen($file) > 3 && ctype_alpha($file[0]) && $file[1] == ':' && ($file[2] == '\\' || $file[2] == '/')))
      {
         if (is_null($this->path))
         {
            throw new RuntimeException('You must give a "path" when you give a relative file name.');
         }

         $smallFile = $this->path.DIRECTORY_SEPARATOR.'s_'.$file;
         $file = $this->path.DIRECTORY_SEPARATOR.$file;
      }

      // get our directory path from the destination filename
      $directory = dirname($file);
      if (!is_readable($directory))
      {
         if ($create && !mkdir($directory, $dirMode, true))
         {
            // failed to create the directory
            throw new Exception(sprintf('Failed to create file upload directory "%s".', $directory));
         }

         // chmod the directory since it doesn't seem to work on recursive paths
         chmod($directory, $dirMode);
      }
      if (!is_dir($directory))
      {
         // the directory path exists but it's not a directory
         throw new Exception(sprintf('File upload path "%s" exists, but is not a directory.', $directory));
      }
      if (!is_writable($directory))
      {
         // the directory isn't writable
         throw new Exception(sprintf('File upload path "%s" is not writable.', $directory));
      }

      // copy the temp file to the destination file
	  $img = new sfImage($this->getTempName());
	  list($target_w, $target_h) = $this->computeTargetSize($img->getWidth(), $img->getHeight(), 200, 100);
	  $img->resize($target_w, $target_h);
	  $img->saveAs($file);

      // chmod our file
      chmod($file, $fileMode);

      $this->savedName = $file;
      return is_null($this->path) ? $file : str_replace($this->path.DIRECTORY_SEPARATOR, '', $file);
   }


/**
   * Compute target size
   *
   * @param integer $source_w
   * @param integer $source_h
   * @return array Target width and height
   */
  protected function computeTargetSize($source_w, $source_h, $dest_w, $dest_h)
  {
    $target_w = $source_w;
    $target_h = $source_h;

    if (null !== $dest_w)
    {
      $target_w = $dest_w;
      if ($target_w > $source_w)
      {
        $target_w = $source_w;
      }

      if ($source_w > 0)
      {
        // Compute the new height in order to keep the aspect ratio
        // and clamp it to the maximum height
        $target_h = round(($source_h / $source_w) * $target_w);

        if (null !== $dest_h && $dest_h < $target_h && $source_h > 0)
        {
          $target_h = $dest_h;
          $target_w = round(($source_w / $source_h) * $target_h);
        }
      }
    }

    if (null !== $dest_h)
    {
      $target_h = $dest_h;
      if ($target_h > $source_h)
      {
        $target_h = $source_h;
      }

      if ($source_h > 0)
      {
        // Compute the new width in order to keep the aspect ratio
        // and clamp it to the maximum width
        $target_w = round(($source_w / $source_h) * $target_h);

        if (null !== $dest_w && $dest_w < $target_w && $target_w > 0)
        {
          $target_w = $dest_w;
          $target_h = round(($source_h / $source_w) * $target_w);
        }
      }
    }

    return array($target_w, $target_h);
  }
}